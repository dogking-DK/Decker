#version 460
#extension GL_EXT_mesh_shader : require

#define WG_SIZE 24
#define VERTS_PER_ARROW 9
#define TRIS_PER_ARROW  3

layout(local_size_x = WG_SIZE) in;
layout(max_vertices   = WG_SIZE * VERTS_PER_ARROW,
       max_primitives = WG_SIZE * TRIS_PER_ARROW,
       triangles) out;

struct GPUVector { vec4 pos; vec4 vel; };

layout(set=0, binding=0, std140) uniform CameraData 
{
    mat4 viewproj;
    mat4 view;
    mat4 proj;
    vec4 eye;
} uCamera;

layout(set=0, binding=1, std430) buffer Vectors 
{
    GPUVector vectors[];
};

layout(push_constant) uniform Push 
{
    mat4  model;
    float baseScale;
    float headRatio;
    float halfWidth;
    float magScale;
} PC;

// ✅ per-primitive 输出：保持“无尺寸数组”写法或显式给大小都可
layout(location = 0) perprimitiveEXT out vec3 pColor[]; // 每个三角的颜色
layout(location = 1) out vec3 vColor[];                 // 每顶点颜色

// ❌ 不要这样重新声明并起名 prim：
// perprimitiveEXT out gl_MeshPerPrimitiveEXT { uint gl_PrimitiveID; } prim[];

// ✅ 如需访问内建 per-primitive 块（一般不需要），只能用内建实例名：
// perprimitiveEXT out gl_MeshPerPrimitiveEXT { uint gl_PrimitiveID; } gl_MeshPrimitivesEXT[];

void emit_arrow(uint aidx, uint vbase, uint pbase)
{
    GPUVector gv = vectors[aidx];
    vec3 P      = (PC.model * vec4(gv.pos.xyz, 1.0)).xyz;
    vec3 V      = gv.vel.xyz;

    // 相机基向量（只要旋转部分）
    mat3 RviewInv = mat3(inverse(uCamera.view));
    vec3 camFwd   = normalize(RviewInv[2]);
    vec3 camUp    = normalize(RviewInv[1]);
    vec3 camRight = normalize(RviewInv[0]);

    // 速度在屏幕平面内的方向
    float mag = length(V);
    vec3 dir  = (mag > 1e-6) ? (V / mag) : camUp;
    vec3 t    = dir - dot(dir, camFwd) * camFwd;
    float tlen= length(t);
    t = (tlen > 1e-6) ? (t / tlen) : camUp;
    vec3 s    = normalize(cross(camFwd, t));

    float length_total = PC.baseScale * (1.0 + PC.magScale * mag);
    float head_len     = clamp(PC.headRatio, 0.1, 0.8) * length_total;
    float shaft_len    = max(length_total - head_len, 1e-6);
    float w            = max(PC.halfWidth, 1e-6);
    float head_w       = w * 1.8;

    vec3 tip = P + t * (shaft_len + head_len);
    vec3 sh0 = P;
    vec3 sh1 = P + t * shaft_len;

    vec3 q1 = sh0 + s * w;
    vec3 q2 = sh0 - s * w;
    vec3 q3 = sh1 + s * w;
    vec3 q4 = sh1 - s * w;

    vec3 h1 = sh1 + s * head_w;
    vec3 h2 = sh1 - s * head_w;

    vec3 pos[VERTS_PER_ARROW] = 
    {
        q1, q2, q3,
        q2, q4, q3,
        h1, h2, tip
    };

    vec3 baseCol = mix(vec3(0.2, 0.4, 1.0), vec3(1.0, 0.3, 0.1), clamp(mag * 0.5, 0.0, 1.0));

    for (uint i = 0; i < VERTS_PER_ARROW; ++i) 
    {
        gl_MeshVerticesEXT[vbase + i].gl_Position = uCamera.viewproj * vec4(pos[i], 1.0);
        vColor[vbase + i] = baseCol;
    }

    gl_PrimitiveTriangleIndicesEXT[pbase + 0] = uvec3(vbase + 0, vbase + 1, vbase + 2);
    gl_PrimitiveTriangleIndicesEXT[pbase + 1] = uvec3(vbase + 3, vbase + 4, vbase + 5);
    gl_PrimitiveTriangleIndicesEXT[pbase + 2] = uvec3(vbase + 6, vbase + 7, vbase + 8);

    pColor[pbase + 0] = baseCol;
    pColor[pbase + 1] = baseCol;
    pColor[pbase + 2] = baseCol;
}

void main()
{
    uint globalBase = gl_WorkGroupID.x * WG_SIZE;
    uint localID    = gl_LocalInvocationIndex;
    uint arrowID    = globalBase + localID;

    uint total      = vectors.length();
    uint groupCount = (globalBase + WG_SIZE <= total) ? WG_SIZE : max(0u, total - globalBase);

    // ✅ EXT 规范：用函数设置输出数量（而不是给变量赋值）
    if (localID == 0) 
    {
        SetMeshOutputsEXT(groupCount * VERTS_PER_ARROW,
                          groupCount * TRIS_PER_ARROW);
    }
    barrier();                 // 同步“输出计数”对全组可见
    if (localID >= groupCount) return;

    uint vbase = localID * VERTS_PER_ARROW;
    uint pbase = localID * TRIS_PER_ARROW;

    emit_arrow(arrowID, vbase, pbase);
}
